import i18n__default from 'i18next';
import { BehaviorSubject, Subject } from 'rxjs';
import { InjectionToken, Inject, Injectable, Pipe, NgModule } from '@angular/core';
import { Title, DOCUMENT } from '@angular/platform-browser';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const I18NEXT_SCOPE = new InjectionToken('I18NEXT_SCOPE');
/** @type {?} */
const I18NEXT_NAMESPACE = new InjectionToken('I18NEXT_NAMESPACE');
/** @type {?} */
const I18NEXT_SERVICE = new InjectionToken('I18NEXT_SERVICE');
/** @type {?} */
const I18NEXT_NAMESPACE_RESOLVER = new InjectionToken('I18NEXT_NAMESPACE_RESOLVER');
/** @type {?} */
const I18NEXT_ERROR_HANDLING_STRATEGY = new InjectionToken('I18NEXT_ERROR_HANDLING_STRATEGY');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class I18NextPipe {
    /**
     * @param {?} translateI18Next
     * @param {?} ns
     * @param {?} scope
     */
    constructor(translateI18Next, ns, scope) {
        this.translateI18Next = translateI18Next;
        this.ns = ns;
        this.scope = scope;
    }
    /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    transform(key, options) {
        options = this.prepareOptions(options);
        /** @type {?} */
        let i18nOpts = this.translateI18Next.options;
        if (options.prependScope === undefined || options.prependScope === true) {
            if (this.scope) {
                key = this.prependScope(key, this.scope, i18nOpts.keySeparator, i18nOpts.nsSeparator);
            }
        }
        if (options.prependNamespace === undefined || options.prependNamespace === true) {
            if (this.ns) {
                key = this.prependNamespace(key, this.ns, i18nOpts.nsSeparator);
            }
        }
        /** @type {?} */
        let result = this.translateI18Next.t(key, options);
        if (options.format) {
            if (result) {
                result = this.translateI18Next
                    .format(result, options.format, this.translateI18Next.language);
            }
        }
        return result;
    }
    /**
     * @private
     * @param {?} key
     * @param {?} scope
     * @param {?} keySeparator
     * @param {?} nsSeparator
     * @return {?}
     */
    prependScope(key, scope, keySeparator, nsSeparator) {
        if (typeof (key) === 'string') {
            key = [key];
        }
        if (typeof (scope) === 'string') {
            scope = [scope];
        }
        /** @type {?} */
        let keysWithScope = [];
        for (let i = 0; i < key.length; i++) {
            /** @type {?} */
            const k = key[i];
            if (!this.keyContainsNsSeparator(k, nsSeparator)) { // Do not set scope, if key contains a namespace
                keysWithScope.push(...scope.map((/**
                 * @param {?} sc
                 * @return {?}
                 */
                sc => this.joinStrings(keySeparator, sc, k))));
            }
            keysWithScope.push(k);
        }
        return keysWithScope;
    }
    /**
     * @private
     * @param {?} key
     * @param {?} ns
     * @param {?} nsSeparator
     * @return {?}
     */
    prependNamespace(key, ns, nsSeparator) {
        if (typeof (key) === 'string') {
            key = [key];
        }
        if (typeof (ns) === 'string') {
            ns = [ns];
        }
        /** @type {?} */
        let keysWithNamespace = [];
        for (let i = 0; i < key.length; i++) {
            /** @type {?} */
            const k = key[i];
            if (!this.keyContainsNsSeparator(k, nsSeparator)) { // Do not set namespace, if key contains a namespace
                keysWithNamespace.push(...ns.map((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => this.joinStrings(nsSeparator, n, k))));
            }
            keysWithNamespace.push(k);
        }
        return keysWithNamespace;
    }
    /**
     * @private
     * @param {?} separator
     * @param {...?} str
     * @return {?}
     */
    joinStrings(separator, ...str) {
        return [...str].join(separator);
    }
    /**
     * @private
     * @param {?} key
     * @param {?} nsSeparator
     * @return {?}
     */
    keyContainsNsSeparator(key, nsSeparator) {
        return key.indexOf(nsSeparator) !== -1;
    }
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    prepareOptions(options) {
        options = options || {};
        if (options.context != null)
            options.context = options.context.toString();
        return options;
    }
}
I18NextPipe.decorators = [
    { type: Injectable },
    { type: Pipe, args: [{
                name: 'i18next'
            },] }
];
/** @nocollapse */
I18NextPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [I18NEXT_SERVICE,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [I18NEXT_NAMESPACE,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [I18NEXT_SCOPE,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class I18NextCapPipe extends I18NextPipe {
    /**
     * @param {?} translateI18Next
     * @param {?} ns
     * @param {?} scope
     */
    constructor(translateI18Next, ns, scope) {
        super(translateI18Next, ns, scope);
    }
    /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    transform(key, options) {
        options = options || {};
        options.format = 'cap';
        return super.transform(key, options);
    }
}
I18NextCapPipe.decorators = [
    { type: Injectable },
    { type: Pipe, args: [{
                name: 'i18nextCap'
            },] }
];
/** @nocollapse */
I18NextCapPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [I18NEXT_SERVICE,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [I18NEXT_NAMESPACE,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [I18NEXT_SCOPE,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NativeErrorHandlingStrategy {
    /**
     * @param {?} resolve
     * @param {?} reject
     * @return {?}
     */
    handle(resolve, reject) {
        return (/**
         * @param {?} err
         * @param {?=} t
         * @return {?}
         */
        (err, t) => {
            /** @type {?} */
            let result = {
                err: err,
                t: t
            };
            resolve(result);
        });
    }
}
class StrictErrorHandlingStrategy {
    /**
     * @param {?} resolve
     * @param {?} reject
     * @return {?}
     */
    handle(resolve, reject) {
        return (/**
         * @param {?} err
         * @param {?=} t
         * @return {?}
         */
        (err, t) => {
            /** @type {?} */
            let result = {
                err: err,
                t: t
            };
            if (!err) {
                resolve(result);
                return;
            }
            reject(err);
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class I18NextFormatPipe {
    /**
     * @param {?} translateI18Next
     */
    constructor(translateI18Next) {
        this.translateI18Next = translateI18Next;
    }
    /**
     * @param {?} value
     * @param {?} options
     * @return {?}
     */
    transform(value, options) {
        /** @type {?} */
        let opts = typeof (options) === 'string' ? { format: options } : options;
        return this.translateI18Next.format(value, opts.format, opts.lng);
    }
}
I18NextFormatPipe.decorators = [
    { type: Injectable },
    { type: Pipe, args: [{
                name: 'i18nextFormat'
            },] }
];
/** @nocollapse */
I18NextFormatPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [I18NEXT_SERVICE,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class I18NextEvents {
    constructor() {
        this.initialized = new BehaviorSubject(false);
        this.loaded = new BehaviorSubject(false);
        this.failedLoading = new Subject();
        this.missingKey = new Subject();
        this.added = new Subject();
        this.removed = new Subject();
        this.languageChanged = new BehaviorSubject(null);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const i18next = i18n__default;
class I18NextService {
    /**
     * @param {?} errorHandlingStrategy
     */
    constructor(errorHandlingStrategy) {
        this.errorHandlingStrategy = errorHandlingStrategy;
        this.events = new I18NextEvents();
        this.language = '';
        this.languages = [];
    }
    /**
     * @return {?}
     */
    get options() {
        return i18next.options;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} plugin
     * @return {THIS}
     */
    use(plugin) {
        i18next.use.call(i18next, plugin);
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    init(options) {
        options = options || {};
        this.subscribeEvents();
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            i18next.init.call(i18next, Object.assign({}, options), this.errorHandlingStrategy.handle(resolve, reject));
        }));
    }
    /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    t(key, options) {
        options = options || {};
        return i18next.t.call(i18next, (/** @type {?} */ (key)), options);
    }
    /**
     * @param {?} value
     * @param {?} format
     * @param {?} lng
     * @return {?}
     */
    format(value, format, lng) {
        return i18next.format.call(i18next, value, format, lng);
    }
    /**
     * @param {?} key
     * @param {?} options
     * @return {?}
     */
    exists(key, options) {
        return i18next.exists.call(i18next, key, options);
    }
    /**
     * @param {?} lng
     * @param {?} ns
     * @return {?}
     */
    getFixedT(lng, ns) {
        return i18next.getFixedT.call(i18next, lng, ns);
    }
    /**
     * @param {?} ns
     * @return {?}
     */
    setDefaultNamespace(ns) {
        i18next.setDefaultNamespace.call(i18next, ns);
    }
    /**
     * @param {?=} lng
     * @return {?}
     */
    dir(lng = undefined) {
        return i18next.dir.call(i18next, lng);
    }
    /**
     * @param {?} lng
     * @return {?}
     */
    changeLanguage(lng) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            i18next.changeLanguage.call(i18next, lng, this.errorHandlingStrategy.handle(resolve, reject));
        }));
    }
    /**
     * @param {?} namespaces
     * @return {?}
     */
    loadNamespaces(namespaces) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            i18next.loadNamespaces.call(i18next, namespaces, this.errorHandlingStrategy.handle(resolve, reject));
        }));
    }
    /**
     * @param {?} lngs
     * @param {?} callback
     * @return {?}
     */
    loadLanguages(lngs, callback) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            i18next.loadNamespaces.call(i18next, lngs, this.errorHandlingStrategy.handle(resolve, reject));
        }));
    }
    //#region resource handling
    /**
     * @param {...?} params
     * @return {?}
     */
    reloadResources(...params) {
        i18next.reloadResources.apply(i18next, params);
    }
    /**
     * @param {?} lng
     * @param {?} ns
     * @param {?} key
     * @param {?} options
     * @return {?}
     */
    getResource(lng, ns, key, options) {
        return i18next.getResource.call(i18next, lng, ns, key, options);
    }
    /**
     * @param {?} lng
     * @param {?} ns
     * @param {?} key
     * @param {?} value
     * @param {?} options
     * @return {?}
     */
    addResource(lng, ns, key, value, options) {
        i18next.addResource.call(i18next, lng, ns, key, value, options);
    }
    /**
     * @param {?} lng
     * @param {?} ns
     * @param {?} resources
     * @return {?}
     */
    addResources(lng, ns, resources) {
        i18next.addResources.call(i18next, lng, ns, resources);
    }
    /**
     * @param {?} lng
     * @param {?} ns
     * @param {?} resources
     * @param {?} deep
     * @param {?} overwrite
     * @return {?}
     */
    addResourceBundle(lng, ns, resources, deep, overwrite) {
        i18next.addResourceBundle.call(i18next, lng, ns, resources, deep, overwrite);
    }
    /**
     * @param {?} lng
     * @param {?} ns
     * @return {?}
     */
    hasResourceBundle(lng, ns) {
        return i18next.hasResourceBundle.call(i18next, lng, ns);
    }
    /**
     * @param {?} lng
     * @param {?} ns
     * @return {?}
     */
    getResourceBundle(lng, ns) {
        return i18next.getResourceBundle.call(i18next, lng, ns);
    }
    /**
     * @param {?} lng
     * @param {?} ns
     * @return {?}
     */
    removeResourceBundle(lng, ns) {
        i18next.removeResourceBundle.call(i18next, lng, ns);
    }
    //#endregion
    /**
     * @private
     * @return {?}
     */
    subscribeEvents() {
        i18next.on.call(i18next, 'initialized', (/**
         * @param {?} options
         * @return {?}
         */
        options => {
            this.language = i18next.language;
            this.languages = i18next.languages;
            this.events.initialized.next(options);
        }));
        i18next.on.call(i18next, 'loaded', (/**
         * @param {?} loaded
         * @return {?}
         */
        loaded => this.events.loaded.next(loaded)));
        i18next.on.call(i18next, 'failedLoading', (/**
         * @param {?} lng
         * @param {?} ns
         * @param {?} msg
         * @return {?}
         */
        (lng, ns, msg) => this.events.failedLoading.next({ lng, ns, msg })));
        i18next.on.call(i18next, 'languageChanged', (/**
         * @param {?} lng
         * @return {?}
         */
        lng => {
            this.language = i18next.language;
            this.languages = i18next.languages;
            this.events.languageChanged.next(lng);
        }));
        i18next.on.call(i18next, 'missingKey', (/**
         * @param {?} lngs
         * @param {?} namespace
         * @param {?} key
         * @param {?} res
         * @return {?}
         */
        (lngs, namespace, key, res) => this.events.missingKey.next({ lngs, namespace, key, res })));
        i18next.on.call(i18next, 'added', (/**
         * @param {?} lng
         * @param {?} ns
         * @return {?}
         */
        (lng, ns) => this.events.added.next({ lng, ns })));
        i18next.on.call(i18next, 'removed', (/**
         * @param {?} lng
         * @param {?} ns
         * @return {?}
         */
        (lng, ns) => this.events.removed.next({ lng, ns })));
    }
}
I18NextService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
I18NextService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [I18NEXT_ERROR_HANDLING_STRATEGY,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class I18NextTitle extends Title {
    /**
     * @param {?} i18nextPipe
     * @param {?} doc
     */
    constructor(i18nextPipe, doc) {
        super(doc);
        this.i18nextPipe = i18nextPipe;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setTitle(value) {
        return super.setTitle(this.translate(value));
    }
    /**
     * @private
     * @param {?} text
     * @return {?}
     */
    translate(text) {
        return this.i18nextPipe.transform(text, { format: 'cap' });
    }
}
I18NextTitle.decorators = [
    { type: Injectable }
];
/** @nocollapse */
I18NextTitle.ctorParameters = () => [
    { type: I18NextPipe },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} activatedRouteSnapshot
 * @param {?} routerStateSnapshot
 * @return {?}
 */
function resolver(activatedRouteSnapshot, routerStateSnapshot) {
    /** @type {?} */
    let namespaces = [];
    namespaces = activatedRouteSnapshot.data && activatedRouteSnapshot.data.i18nextNamespaces || namespaces;
    return this.loadNamespaces(namespaces.filter((/**
     * @param {?} n
     * @return {?}
     */
    n => n)));
}
/**
 * @param {?} i18next
 * @return {?}
 */
function i18nextNamespaceResolverFactory(i18next) {
    return resolver.bind(i18next);
}
class I18NextModule {
    /**
     * @param {?=} params
     * @return {?}
     */
    static forRoot(params = {}) {
        return {
            ngModule: I18NextModule,
            providers: [
                {
                    provide: I18NEXT_SERVICE,
                    useClass: I18NextService
                },
                {
                    provide: I18NEXT_ERROR_HANDLING_STRATEGY,
                    useClass: params.errorHandlingStrategy || NativeErrorHandlingStrategy
                },
                I18NextService,
                I18NextPipe,
                I18NextCapPipe,
                I18NextFormatPipe,
                I18NextTitle,
                {
                    provide: I18NEXT_NAMESPACE_RESOLVER,
                    useFactory: i18nextNamespaceResolverFactory,
                    deps: [I18NEXT_SERVICE]
                }
            ]
        };
    }
    /**
     * @param {?=} customFormat
     * @return {?}
     */
    static interpolationFormat(customFormat = null) {
        /**
         * @param {?} value
         * @param {?} format
         * @param {?} lng
         * @return {?}
         */
        function formatDelegate(value, format, lng) {
            /** @type {?} */
            let formatedValue = defaultInterpolationFormat(value, format, lng);
            if (customFormat === null)
                return formatedValue;
            return customFormat(formatedValue, format, lng);
        }
        return formatDelegate;
    }
}
I18NextModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    {
                        provide: I18NEXT_NAMESPACE,
                        useValue: ''
                    },
                    {
                        provide: I18NEXT_SCOPE,
                        useValue: ''
                    },
                    I18NextPipe,
                    I18NextCapPipe,
                    I18NextFormatPipe,
                    I18NextTitle
                ],
                declarations: [
                    I18NextPipe,
                    I18NextCapPipe,
                    I18NextFormatPipe
                ],
                exports: [
                    I18NextPipe,
                    I18NextCapPipe,
                    I18NextFormatPipe
                ]
            },] }
];
/**
 * @param {?} value
 * @param {?} format
 * @param {?=} lng
 * @return {?}
 */
function defaultInterpolationFormat(value, format, lng = undefined) {
    if (!value)
        return value;
    switch (format) {
        case 'upper':
        case 'uppercase':
            return value.toUpperCase();
        case 'lower':
        case 'lowercase':
            return value.toLowerCase();
        case 'cap':
        case 'capitalize':
            return value.charAt(0).toUpperCase() + value.slice(1);
        case null:
        case undefined:
        case 'none':
        default:
            return value;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { resolver, i18nextNamespaceResolverFactory, defaultInterpolationFormat, I18NextModule, I18NEXT_SCOPE, I18NEXT_NAMESPACE, I18NEXT_SERVICE, I18NEXT_NAMESPACE_RESOLVER, I18NEXT_ERROR_HANDLING_STRATEGY, I18NextPipe, I18NextCapPipe, I18NextFormatPipe, I18NextService, I18NextTitle, NativeErrorHandlingStrategy, StrictErrorHandlingStrategy };

//# sourceMappingURL=angular-i18next.js.map